use log::trace;
extern crate rand_core;
extern crate rand_xorshift;

use fnv::FnvHashMap;
use fnv::FnvHashSet;
use rand::Rng;

use crate::bitset::BitSet;
use crate::model::board::Board;
use crate::model::tile::Tile;
use crate::model::tile::TileKind;
use crate::model::tile::TileWithModifier;
use crate::model::util::Position;
use crate::model::util::SpriteAndWantsToMove;
use crate::model::util::SpriteState;
use crate::model::util::WantsToMove;

pub fn build_tile_with_modifier(
    random: bool,
    is_or: bool,
    negated: bool,
    direction: Option<WantsToMove>,
    sprites: &Vec<SpriteState>,
) -> TileWithModifier {
    let tile_kind = if is_or { TileKind::Or } else { TileKind::And };
    let tile = Tile::new(
        tile_kind,
        &String::from("autogenerated_name"),
        sprites.clone(),
    );

    TileWithModifier {
        negated,
        direction,
        tile,
        random,
    }
}

pub fn build_t(
    random: bool,
    sprite: &SpriteState,
    negated: bool,
    dir: Option<WantsToMove>,
) -> TileWithModifier {
    build_tile_with_modifier(random, false, negated, dir, &vec![sprite.clone()])
}

#[derive(Clone, Debug)]
struct AddTile {
    collision_layer: u16,
    new_direction: Option<WantsToMove>,
    action_tile_with_modifier: TileWithModifier,
}

fn get_dir<R: Rng + ?Sized>(rng: &mut R, new_direction: Option<WantsToMove>) -> WantsToMove {
    if let Some(WantsToMove::RandomDir) = new_direction {
        trace!("PICKING RANDOMDIR");
        // Find a random direction
        match rng.gen_range(0, 4) {
            0 => WantsToMove::Up,
            1 => WantsToMove::Down,
            2 => WantsToMove::Left,
            3 => WantsToMove::Right,
            _ => panic!("BUG: Random generator should not generate a value that is not [0-3]"),
        }
    } else {
        new_direction.unwrap_or(WantsToMove::Stationary)
    }
}

impl AddTile {
    fn evaluate<R: Rng + ?Sized>(
        &self,
        rng: &mut R,
        board: &mut Board,
        pos: &Position,
        magic_or_tiles: &FnvHashMap<Tile, Vec<SpriteState>>,
    ) -> bool {
        let mut something_evaluated = false;
        let t = &self.action_tile_with_modifier;

        if t.random {
            let sprites = t.tile.get_sprites();
            let rnd = rng.gen_range(0, sprites.len());
            let dir = get_dir(rng, self.new_direction);
            let ret = board.add_sprite(pos, &sprites[rnd], dir);
            trace!(
                "Adding random sprite={} dir={} to {:?}. Did it? {}",
                sprites[rnd],
                dir,
                pos,
                ret
            );
            return ret;
        }

        match t.tile.kind {
            TileKind::Or => {
                // There is no sprite of this type already in the cell. It's in the magicOrTiles
                match magic_or_tiles.get(&t.tile) {
                    None => panic!(
                        "Magic OR tile '{}' not found. Here are all the tiles: {:?}",
                        t.tile.name, magic_or_tiles
                    ),
                    Some(sprites) => {
                        for sprite in sprites {
                            trace!("Adding Magic sprite={} to {:?}", sprite, pos);
                            something_evaluated |=
                                board.add_sprite(pos, sprite, get_dir(rng, self.new_direction));
                        }
                    }
                }
            }
            TileKind::And => {
                for sprite in t.tile.get_sprites() {
                    trace!("Adding sprite={} to {:?}", sprite, pos);
                    let current_direction = board.get_wants_to_move(pos, sprite.collision_layer);
                    something_evaluated |= board.add_sprite(
                        pos,
                        sprite,
                        self.new_direction
                            .unwrap_or(current_direction.unwrap_or(WantsToMove::Stationary)),
                    );
                }
            }
        }
        something_evaluated
    }
}

#[derive(Clone, Debug)]
struct RemoveTile {
    collision_layer: u16,
    might_not_find_condition_but_that_is_ok: bool,
    condition_sprites_to_remove: TileWithModifier,
}

impl RemoveTile {
    fn evaluate(
        &self,
        board: &mut Board,
        pos: &Position,
        or_tiles_removed: &mut FnvHashSet<Tile>,
    ) -> bool {
        // For OR tiles we need to only remove one of the sprites, not ALL of the sprites (triple-match)
        if self.condition_sprites_to_remove.tile.is_or() {
            if !or_tiles_removed.contains(&self.condition_sprites_to_remove.tile) {
                let tile = board.get_collision_layer(pos, self.collision_layer);
                if tile.is_none() && self.might_not_find_condition_but_that_is_ok {
                    // this occurs when there is just a -> [ NO Color ] on the action side (remove color if it exists)
                    return false;
                }
                let tile = SpriteState::new(
                    &String::from("temp-removetile"),
                    tile.unwrap().sprite_index,
                    self.collision_layer,
                ); // just build a sprite

                // only remove the sprites in the cell that match the condition... not all the sprites in a collisionLayer
                let cell_sprite = tile;

                for condition_sprite_to_remove in
                    self.condition_sprites_to_remove.tile.get_sprites()
                {
                    if cell_sprite == *condition_sprite_to_remove {
                        let removed =
                            board.remove_collision_layer(pos, cell_sprite.collision_layer);

                        if removed {
                            or_tiles_removed.insert(self.condition_sprites_to_remove.tile.clone());
                            return true;
                        }
                    }
                }
                false
            } else {
                false
            }
        } else {
            let sprite = board.get_collision_layer(pos, self.collision_layer);
            match sprite {
                None => {
                    if self.might_not_find_condition_but_that_is_ok {
                        return false;
                    }
                    panic!("Could not find tile to remove. Bug?")
                }
                Some(_) => {
                    trace!("Removing tile c={} at {:?}", self.collision_layer, pos);
                    board.remove_collision_layer(pos, self.collision_layer)
                }
            }
        }
    }
}

#[derive(Clone, Debug)]
struct ReplaceDirection {
    collision_layer: u16,
    new_direction: WantsToMove,
    might_not_find_condition_but_that_is_ok: bool,
}

impl ReplaceDirection {
    fn evaluate<R: Rng + ?Sized>(&self, rng: &mut R, board: &mut Board, pos: &Position) -> bool {
        let cell_sprites = board.has_collision_layer(pos, self.collision_layer);
        if self.might_not_find_condition_but_that_is_ok && !cell_sprites {
            return false;
        }

        trace!(
            "Replacing direction on {} to be {:?}",
            self.collision_layer,
            self.new_direction
        );
        board.set_wants_to_move(
            pos,
            self.collision_layer,
            get_dir(rng, Some(self.new_direction)),
        )
    }
}

#[derive(Clone, PartialEq, Debug)]
struct ExtraPair<T, E> {
    condition: T,
    action: T,
    extra: E,
}

impl<T, E> ExtraPair<T, E> {
    fn new(condition: T, action: T, extra: E) -> Self {
        Self {
            condition,
            action,
            extra,
        }
    }
}

#[derive(Clone, Debug)]
pub struct Neighbor {
    pub prepared_actions: bool,
    pub tiles_with_modifier: Vec<TileWithModifier>,
    add_tiles: Vec<AddTile>,       // can be a set
    remove_tiles: Vec<RemoveTile>, // can be a set
    replace_directions: Vec<ReplaceDirection>,

    all_sprites: BitSet,
    any_sprites: BitSet,
    no_sprites: BitSet,

    all_sprites2: BitSet,
    any_sprites2: Vec<BitSet>,
    no_sprites2: BitSet,

    all_directions: FnvHashMap<u16, WantsToMove>,
    all_multi_collision_layer_tiles: Vec<TileWithModifier>,
    or_tile_movements_present: Vec<(Tile, WantsToMove)>,
    sprite_movements_present: FnvHashMap<u16, WantsToMove>,
}

impl Neighbor {
    pub fn new(tiles_with_modifier: Vec<TileWithModifier>) -> Self {
        let mut all_sprites = BitSet::new();
        let mut any_sprites = BitSet::new();
        let mut no_sprites = BitSet::new();

        let mut all_sprites2 = BitSet::new();
        let mut any_sprites2 = vec![];
        let mut no_sprites2 = BitSet::new();
        let mut all_directions = FnvHashMap::default();
        let mut all_multi_collision_layer_tiles = vec![];
        let mut or_tile_movements_present = vec![];
        let mut sprite_movements_present = FnvHashMap::default();

        for t in &tiles_with_modifier {
            if t.negated {
                match t.tile.kind {
                    TileKind::And => {
                        if t.tile.sprites.len() == 1 {
                            no_sprites.insert_all(&t.tile.bits)
                        }
                    }
                    TileKind::Or => no_sprites.insert_all(&t.tile.bits),
                }
            } else {
                match t.tile.kind {
                    TileKind::And => all_sprites.insert_all(&t.tile.bits),
                    TileKind::Or => any_sprites.insert_all(&t.tile.bits),
                }
            }
        }

        for t in &tiles_with_modifier {
            if t.negated {
                if t.tile.has_single_collision_layer() {
                    no_sprites2.insert_all(&t.tile.bits);
                } else {
                    all_multi_collision_layer_tiles.push(t.clone());
                }
            } else {
                if t.tile.has_single_collision_layer() {
                    // all_sprites2.insert_all(&t.tile.bits);

                    for sprite in &t.tile.sprites {
                        if let Some(dir) = t.direction {
                            all_directions.insert(sprite.collision_layer, dir);
                        }
                    }
                } else {
                    all_multi_collision_layer_tiles.push(t.clone());
                }

                if t.tile.is_or() {
                    any_sprites2.push(t.tile.bits.clone());
                    if let Some(dir) = t.direction {
                        or_tile_movements_present.push((t.tile.clone(), dir));
                    }
                } else {
                    all_sprites2.insert_all(&t.tile.bits);
                    for s in &t.tile.sprites {
                        if let Some(dir) = t.direction {
                            sprite_movements_present.insert(s.collision_layer, dir);
                        }
                    }
                }
            }
        }
        assert_eq!(all_sprites, all_sprites2);

        Self {
            prepared_actions: false,
            tiles_with_modifier,
            add_tiles: vec![],
            remove_tiles: vec![],
            replace_directions: vec![],

            all_sprites,
            any_sprites,
            no_sprites,

            all_sprites2,
            any_sprites2,
            no_sprites2,
            all_directions,
            all_multi_collision_layer_tiles,
            or_tile_movements_present,
            sprite_movements_present,
        }
    }

    fn check1(&self, cell_bits: &BitSet) -> bool {
        cell_bits.contains_none(&self.no_sprites2)
    }

    fn check2(&self, cell_bits: &BitSet) -> bool {
        cell_bits.contains_all(&self.all_sprites2)
    }

    fn check3(&self, cell_bits: &BitSet) -> bool {
        for bs in &self.any_sprites2 {
            if !cell_bits.contains_any(bs) {
                return false;
            }
        }
        true
    }

    fn check4(&self, cell_map: &FnvHashMap<u16, SpriteAndWantsToMove>) -> bool {
        for (c, dir) in &self.sprite_movements_present {
            match cell_map.get(&c) {
                None => return false,
                Some(sw) => {
                    if &sw.wants_to_move != dir {
                        return false;
                    }
                }
            }
        }
        true
    }

    fn check5(&self, cell_bits: &BitSet, cell_map: &FnvHashMap<u16, SpriteAndWantsToMove>) -> bool {
        for (tile, dir) in &self.or_tile_movements_present {
            if tile.has_single_collision_layer() {
                let set = tile.get_collision_layers();
                match cell_map.get(set.iter().next().unwrap()) {
                    None => return false,
                    Some(sw) => {
                        if dir != &sw.wants_to_move {
                            return false;
                        }
                    }
                }
            } else {
                // find which sprite in the OR tile matched and get its direction
                let mut found_sprite = false;
                // the OR tile can match multiple sprites so make sure at least one matched (not all)
                // e.g:
                // Movable = Player OR Island
                // Rule: [ LEFT Movable ]
                // Cell: STATIONARY Player LEFT Island
                let mut did_match = false;
                for sprite in &tile.sprites {
                    if cell_bits.contains(sprite.index) {
                        found_sprite = true;
                        match cell_map.get(&sprite.collision_layer) {
                            None => {}
                            Some(sw) => {
                                if dir == &sw.wants_to_move {
                                    did_match = true;
                                }
                            }
                        }
                    }
                }
                if !did_match {
                    return false;
                }
                assert!(
                    found_sprite,
                    "BUG: Could not find sprite. One should have already been matched before"
                );
            }
        }
        true
    }

    pub fn check6(&self, board: &Board, pos: &Position) -> bool {
        for t in &self.all_multi_collision_layer_tiles {
            if !t.matches(board, pos) {
                return false;
            }
        }
        true
    }

    pub fn matches(&self, board: &Board, pos: &Position) -> bool {
        let cell_sprites = board.as_sprites(pos);

        let ret = self.check1(cell_sprites)
            && self.check2(cell_sprites)
            && self.check3(cell_sprites)
            && self.check4(board.as_map(pos))
            && self.check5(cell_sprites, board.as_map(pos))
            && self.check6(board, pos);

        // Check that the bitset caches respond correctly
        let debug_check = || {
            let naive = cell_sprites.contains_any(&self.any_sprites)
                && cell_sprites.contains_none(&self.no_sprites)
                && cell_sprites.contains_all(&self.all_sprites)
                && self.matches_no_cache(board, pos);
            if ret != naive {
                eprintln!(
                    "neighbor... {}, pos: {} cell:{:?}",
                    self,
                    pos,
                    board.as_map(&pos)
                );
                eprintln!(
                    "Expected... {} but found {} {} {} {} {} {}",
                    naive,
                    self.check1(cell_sprites),
                    self.check2(cell_sprites),
                    self.check3(cell_sprites),
                    self.check4(board.as_map(pos)),
                    self.check5(cell_sprites, board.as_map(pos)),
                    self.check6(board, pos)
                );
            }
            ret == naive
        };
        debug_assert!(debug_check());

        ret
    }

    fn matches_no_cache(&self, board: &Board, pos: &Position) -> bool {
        for t in &self.tiles_with_modifier {
            if !t.matches(board, pos) {
                return false;
            }
        }
        true
    }

    // Returns true if this neighbor causes changes to the board
    pub fn prepare_actions(&mut self, action: &Neighbor) -> bool {
        let pairs = self.pair_up_tiles(action);

        for (c, pair) in pairs {
            let condition = pair.condition;
            let action = pair.action;
            let extra = pair.extra;

            if condition.is_some() && action.is_some() {
                let condition = condition.unwrap();
                let action = action.unwrap();
                if condition != action {
                    // Could be `[ TrolleyFull no CleanDishes] -> [TrolleyEmpty no CleanDishes ]`
                    let new_direction;
                    if condition.direction != action.direction || condition.negated {
                        new_direction =
                            Some(action.direction.clone().unwrap_or(WantsToMove::Stationary));
                    } else {
                        new_direction = None;
                    }

                    if condition.tile != action.tile || condition.negated {
                        self.add_tiles.push(AddTile {
                            collision_layer: c,
                            new_direction,
                            action_tile_with_modifier: action,
                        });
                    } else if action.negated {
                        self.remove_tiles.push(RemoveTile {
                            collision_layer: c,
                            might_not_find_condition_but_that_is_ok: extra,
                            condition_sprites_to_remove: condition,
                        });
                    } else if condition.random {
                        self.replace_directions.push(ReplaceDirection {
                            collision_layer: c,
                            new_direction: WantsToMove::Stationary,
                            might_not_find_condition_but_that_is_ok: extra,
                        });
                    } else if new_direction.is_some() {
                        self.replace_directions.push(ReplaceDirection {
                            collision_layer: c,
                            new_direction: new_direction.unwrap(),
                            might_not_find_condition_but_that_is_ok: extra,
                        });
                    }
                }
            } else if condition.is_some() {
                let condition = condition.unwrap();
                if !condition.negated {
                    self.remove_tiles.push(RemoveTile {
                        collision_layer: c,
                        might_not_find_condition_but_that_is_ok: extra,
                        condition_sprites_to_remove: condition,
                    });
                }
            } else if action.is_some() {
                let action = action.unwrap();
                if !action.negated {
                    let new_direction =
                        Some(action.direction.clone().unwrap_or(WantsToMove::Stationary));
                    self.add_tiles.push(AddTile {
                        collision_layer: c,
                        action_tile_with_modifier: action,
                        new_direction,
                    });
                }
            }
        }
        self.prepared_actions = true;

        self.add_tiles.len() > 0 || self.remove_tiles.len() > 0 || self.replace_directions.len() > 0
    }

    pub fn evaluate<R: Rng + ?Sized>(
        &self,
        rng: &mut R,
        board: &mut Board,
        pos: &Position,
        magic_or_tiles: &FnvHashMap<Tile, Vec<SpriteState>>,
    ) -> bool {
        assert!(
            self.prepared_actions,
            "Forgot to call prepare_actions on the Neighbor"
        );
        debug_assert!(
            self.matches(board, pos),
            "Should have already checked to see if this neighbor matches"
        );

        let mut or_tiles_removed = FnvHashSet::default();
        let mut something_evaluated = false;
        for r in &self.remove_tiles {
            something_evaluated |= r.evaluate(board, pos, &mut or_tiles_removed);
        }
        for r in &self.add_tiles {
            something_evaluated |= r.evaluate(rng, board, pos, magic_or_tiles);
        }
        for r in &self.replace_directions {
            something_evaluated |= r.evaluate(rng, board, pos);
        }
        something_evaluated
    }

    fn pair_up_tiles(
        &self,
        action: &Neighbor,
    ) -> FnvHashMap<u16, ExtraPair<Option<TileWithModifier>, bool>> {
        let mut pairs = FnvHashMap::default();
        let mut or_tiles = FnvHashMap::default();

        // Fill up the condition side
        for t in &self.tiles_with_modifier {
            if t.tile.is_or() && !t.tile.has_single_collision_layer() {
                if !t.negated {
                    or_tiles.insert(t.tile.clone(), t);
                }
            } else {
                // AND Tiles can have multiple collisionLayers too...
                // loop over each collisionLayer
                for c in t.tile.get_collision_layers() {
                    pairs
                        .entry(*c)
                        .or_insert(ExtraPair::new(Some(t.clone()), None, false));
                }
            }
        }

        // Fill up the action side
        let mut unmatched_or_tiles = or_tiles.clone();
        for t in &action.tiles_with_modifier {
            if t.tile.is_or() && !t.tile.has_single_collision_layer() {
                // OR tiles may belong to different collisionlayers so... it's complicated
                match or_tiles.get(&t.tile) {
                    Some(condition_tile) => {
                        unmatched_or_tiles.remove(&t.tile);
                        // simple case. at most we just change direction
                        if condition_tile.negated == t.negated && condition_tile.direction != t.direction {
                            for sprite in t.tile.get_sprites() {
                                let c = sprite.collision_layer;

                                if !pairs.contains_key(&c) {
                                    pairs.insert(
                                        c,
                                        ExtraPair::new(
                                            Some(build_t(
                                                condition_tile.random,
                                                sprite,
                                                condition_tile.negated,
                                                condition_tile.direction,
                                            )),
                                            Some(build_t(t.random, sprite, t.negated, t.direction)),
                                            true, /*okToIgnoreNonMatches*/
                                        ),
                                    );
                                }
                            }
                        } else if t.negated {
                            for sprite in t.tile.get_sprites() {
                                let c = sprite.collision_layer;

                                if !pairs.contains_key(&c) {
                                    pairs.insert(
                                        c,
                                        ExtraPair::new(
                                            Some(build_t(
                                                condition_tile.random,
                                                sprite,
                                                condition_tile.negated,
                                                condition_tile.direction,
                                            )),
                                            Some(build_t(t.random, sprite, t.negated, t.direction)),
                                            true, /*okToIgnoreNonMatches*/
                                        ),
                                    );
                                }
                            }
                        }
                    }
                    None => {
                        let t2 = TileWithModifier {
                            negated: false,
                            random: t.random,
                            direction: t.direction,
                            tile: t.tile.clone(),
                        };
                        if t.negated {
                            for sprite in t.tile.get_sprites() {
                                let c = sprite.collision_layer;
                                if !pairs.contains_key(&c) {
                                    pairs.insert(
                                        c,
                                        ExtraPair::new(
                                            Some(t2.clone()),
                                            None,
                                            true, /*okToIgnoreNonMatches*/
                                        ),
                                    );
                                }
                            }
                        } else {
                            for sprite in t.tile.get_sprites() {
                                let c = sprite.collision_layer;
                                if !pairs.contains_key(&c) {
                                    pairs.insert(
                                        c,
                                        ExtraPair::new(
                                            None,
                                            Some(t2.clone()),
                                            true, /*okToIgnoreNonMatches*/
                                        ),
                                    );
                                }
                            }
                        }
                    }
                }
            } else {
                for c in t.tile.get_collision_layers() {
                    // if the condition is the same as the action then it's a no-op and we can remove the code
                    let p = pairs.get(c);
                    if p.is_some() && p.expect("It's here, I know it").condition == Some(t.clone())
                    {
                        // condition and action are the same. No need to add a Pair
                        pairs.remove(c);
                    } else {
                        if t.negated {
                            // set it to be null (removed)
                            if let Some(p) = p {
                                // just leave the action side as null (so it's removed)
                                if p.condition == Some(t.clone()) {
                                    panic!("BUG: Unreachable code");
                                }
                            } else {
                                // we need to set the condition side to be the tile so that it is removed
                                // (it might not exist in the cell though but that's an optimization for later)
                                let t2 = TileWithModifier {
                                    negated: false, // since the action side is a NO
                                    random: false,
                                    direction: t.direction.clone(),
                                    tile: t.tile.clone(),
                                };
                                pairs.insert(*c, ExtraPair::new(Some(t2), None, true));
                            }
                        } else {
                            if p.is_some() {
                                let p2 = p.expect("Its here I know it");
                                let new =
                                    ExtraPair::new(p2.condition.clone(), Some(t.clone()), p2.extra);
                                pairs.insert(*c, new);
                            } else {
                                pairs.insert(*c, ExtraPair::new(None, Some(t.clone()), false));
                            }
                        }
                    }
                }
            }
        }

        // Any unmatched OR tiles need to be removed from the Cell
        if !unmatched_or_tiles.is_empty() {
            for t in unmatched_or_tiles.values() {
                for sprite in &t.tile.sprites {
                    let c = sprite.collision_layer;
                    pairs.entry(c).or_insert_with(|| {
                        let t2 = TileWithModifier {
                            random: false,
                            negated: false,
                            tile: t.tile.clone(),
                            direction: t.direction,
                        };
                        ExtraPair::new(Some(t2), None, true)
                    });
                }
            }
        }

        pairs
    }

    pub fn populate_magic_or_tiles(
        &self,
        magic_or_tiles: &mut FnvHashMap<Tile, Vec<SpriteState>>,
        board: &Board,
        pos: &Position,
    ) {
        for t in &self.tiles_with_modifier {
            if !t.negated && t.tile.is_or() {
                let sprites = t
                    .tile
                    .get_sprites()
                    .iter()
                    .filter(|s| board.has_sprite(pos, s))
                    .map(|s| *s)
                    .collect();
                magic_or_tiles.insert(t.tile.clone(), sprites);
            }
        }
    }

    pub fn populate_cache(
        &self,
        all: &mut BitSet,
        any: &mut BitSet,
        sprite_movements_present: &mut FnvHashSet<(u16, WantsToMove)>,
    ) {
        all.insert_all(&self.all_sprites);
        any.insert_all(&self.any_sprites);
        for (k, v) in &self.sprite_movements_present {
            sprite_movements_present.insert((*k, v.clone()));
        }
    }
}

#[cfg(test)]
pub mod tests {
    use super::*;

    use rand_core::SeedableRng;
    use rand_xorshift::XorShiftRng;

    use crate::model::board::Board;
    use crate::model::util::Position;

    pub fn new_rng() -> XorShiftRng {
        XorShiftRng::from_seed([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])
    }

    pub fn check_counts(condition: &Neighbor, direction: usize, added: usize, removed: usize) {
        assert_eq!(
            direction,
            condition.replace_directions.len(),
            "Direction Mismatched: (expected, actual)"
        );
        assert_eq!(
            added,
            condition.add_tiles.len(),
            "AddTiles Mismatched: (expected, actual)"
        );
        assert_eq!(
            removed,
            condition.remove_tiles.len(),
            "RemoveTiles Mismatched: (expected, actual)"
        );
    }

    #[test]
    fn tiles_with_modifier() {
        let player_sprite = SpriteState::new(&String::from("player"), 0, 0);
        let crate_sprite = SpriteState::new(&String::from("crate"), 1, 0); // same collision but different sprite index
        let target_sprite = SpriteState::new(&String::from("target"), 0, 1); // different collision but same sprite index

        let origin = Position::new(0, 0);
        let mut board = Board::new(1, 1);
        board.add_sprite(&origin, &player_sprite, WantsToMove::Right);

        // Check that the player is in the cell
        assert!(build_tile_with_modifier(
            false, /*random*/
            false, /*is_or*/
            false, /*negated*/
            None,
            &vec![player_sprite]
        )
        .matches(&board, &origin));
        // Check that tile negation works
        assert!(!build_tile_with_modifier(
            false, /*random*/
            false, /*is_or*/
            true,  /*negated*/
            None,
            &vec![player_sprite]
        )
        .matches(&board, &origin));

        // Check that the player is NOT stationary
        assert!(!build_tile_with_modifier(
            false, /*random*/
            false, /*is_or*/
            false, /*negated*/
            Some(WantsToMove::Stationary),
            &vec![player_sprite]
        )
        .matches(&board, &origin));
        // Check that the player is moving Right
        assert!(build_tile_with_modifier(
            false, /*random*/
            false, /*is_or*/
            false, /*negated*/
            Some(WantsToMove::Right),
            &vec![player_sprite]
        )
        .matches(&board, &origin));

        // Verify that crates and targets do NOT match
        assert!(!build_tile_with_modifier(
            false, /*random*/
            false, /*is_or*/
            false, /*negated*/
            None,
            &vec![crate_sprite]
        )
        .matches(&board, &origin));
        assert!(!build_tile_with_modifier(
            false, /*random*/
            false, /*is_or*/
            false, /*negated*/
            None,
            &vec![target_sprite]
        )
        .matches(&board, &origin));

        // Verify that "Player AND Target" does NOT match
        assert!(!build_tile_with_modifier(
            false, /*random*/
            false, /*is_or*/
            false, /*negated*/
            None,
            &vec![player_sprite, target_sprite]
        )
        .matches(&board, &origin));

        // Verify that "Player OR Target" does match
        assert!(build_tile_with_modifier(
            false, /*random*/
            true,  /*is_or*/
            false, /*negated*/
            None,
            &vec![player_sprite, target_sprite]
        )
        .matches(&board, &origin));

        // Verify that "Player OR Crate" matches
        assert!(build_tile_with_modifier(
            false, /*random*/
            true,  /*is_or*/
            false, /*negated*/
            None,
            &vec![player_sprite, crate_sprite]
        )
        .matches(&board, &origin));

        // Ensure subsequent checks are possible
        let t = build_tile_with_modifier(
            false, /*random*/
            false, /*is_or*/
            false, /*negated*/
            None,
            &vec![player_sprite],
        );
        assert!(t.matches(&board, &origin));
        assert!(t.matches(&board, &origin));
    }

    #[test]
    fn replace_direction() {
        let player = SpriteState::new(&String::from("player"), 33, 44);
        let origin = Position::new(0, 0);
        let mut board = Board::new(1, 1);

        board.add_sprite(&origin, &player, WantsToMove::Stationary);
        let mut condition = Neighbor::new(vec![build_t(
            false, /*random*/
            &player, false, /*negated*/
            None,
        )]);
        let action = Neighbor::new(vec![build_t(
            false, /*random*/
            &player,
            false, /*negated*/
            Some(WantsToMove::Right),
        )]);
        condition.prepare_actions(&action);
        assert!(condition.evaluate(&mut new_rng(), &mut board, &origin, &FnvHashMap::default()));
    }

    #[test]
    fn matches_no_or() {
        let player = SpriteState::new(&String::from("player"), 2, 0);
        let bat = SpriteState::new(&String::from("bat"), 3, 1);
        let hat = SpriteState::new(&String::from("bat"), 4, 2);

        let no_player = build_t(false /*random*/, &player, true, None);
        let no_hat = build_t(false /*random*/, &hat, true, None);

        // thing = player OR bat
        // [ NO thing ]
        let no_thing = build_tile_with_modifier(
            false, /*random*/
            true,  /*is_or*/
            true,  /*negated*/
            None,
            &vec![player, bat],
        );

        let origin = Position::new(0, 0);
        let mut board = Board::new(1, 1);

        // let n = Neighbor::new(vec![no_thing.clone()]);
        let n = Neighbor::new(vec![no_thing, no_player, no_hat]);
        assert!(n.matches(&board, &origin));

        board.add_sprite(&origin, &player, WantsToMove::Stationary);
        assert!(!n.matches(&board, &origin));
    }

    #[test]
    fn random_dir() {
        let mut rng = new_rng();
        let player = SpriteState::new(&String::from("player"), 33, 44);

        let player_any = build_t(false /*random*/, &player, false, None);
        let player_random = build_t(
            false, /*random*/
            &player,
            false,
            Some(WantsToMove::RandomDir),
        );

        // [ Player ] -> [ RANDOMDIR Player ]     : 1 direction (Right)
        let mut c1 = Neighbor::new(vec![player_any.clone()]);
        let action = Neighbor::new(vec![player_random.clone()]);
        c1.prepare_actions(&action);
        check_counts(&c1, 1, 0, 0);

        // Check that the Neighbors change the Cell properly
        let mut board = Board::new(1, 1);
        let origin = Position::new(0, 0);

        board.add_sprite(&origin, &player, WantsToMove::Stationary);

        let magic_or_tiles = FnvHashMap::default();

        assert!(c1.evaluate(&mut rng, &mut board, &origin, &magic_or_tiles)); // [ Player ] -> [ RANDOMDIR Player ]
        assert!(board.has_sprite(&origin, &player));
        assert_eq!(
            board.get_wants_to_move(&origin, player.collision_layer),
            Some(WantsToMove::Up)
        ); // The direction is based on RNG
    }

    #[test]
    fn prepare_negation() {
        let mut rng = new_rng();
        let player = SpriteState::new(&String::from("player"), 33, 44);

        let player_any = build_t(false /*random*/, &player, false, None);
        let mut no_player = player_any.clone();
        no_player.negated = true;

        // [ Player ] -> [ RANDOMDIR Player ]     : 1 direction (Right)
        let mut c1 = Neighbor::new(vec![player_any.clone()]);
        let action = Neighbor::new(vec![no_player.clone()]);
        assert!(c1.prepare_actions(&action));
    }

    #[test]
    fn prepare_or_negation() {
        let mut rng = new_rng();
        let player = SpriteState::new(&String::from("player"), 33, 44);
        let hat = SpriteState::new(&String::from("hat"), 11, 22);

        let thing_any = build_tile_with_modifier(false, true, false, None, &vec![player, hat]);
        let no_thing = build_tile_with_modifier(false, true, true, None, &vec![player, hat]);

        // [ Thing ] -> [ NO Thing ]     : 1 direction (Right)
        let mut c1 = Neighbor::new(vec![thing_any.clone()]);
        let action = Neighbor::new(vec![no_thing.clone()]);
        assert!(c1.prepare_actions(&action));

        check_counts(&c1, 0, 0, 2);
    }

    #[test]
    fn prepare_neighbor_single_sprite() {
        let mut rng = new_rng();
        let player = SpriteState::new(&String::from("player"), 33, 44);

        let player_any = build_t(false /*random*/, &player, false, None);
        let player_right = build_t(
            false, /*random*/
            &player,
            false,
            Some(WantsToMove::Right),
        );
        let no_player = build_t(false /*random*/, &player, true, None);

        // [ player ] -> [ > player ]     : 1 direction (Right)
        // [ ]        -> [ player ]       : 1 added (Stationary)
        // [ NO player ] -> [ player ]    : 1 added (Stationary)
        // [ NO player ] -> [ > player ]  : 1 added (Right)
        // [ player ] -> [ ]              : 1 removed

        // [ player ] -> [ > player ]     : 1 direction (Right)
        let mut c1 = Neighbor::new(vec![player_any.clone()]);
        let action = Neighbor::new(vec![player_right.clone()]);
        c1.prepare_actions(&action);
        check_counts(&c1, 1, 0, 0);

        // [ ]        -> [ player ]       : 1 added (Stationary)
        let mut c2 = Neighbor::new(vec![]);
        let action = Neighbor::new(vec![player_any.clone()]);
        c2.prepare_actions(&action);
        check_counts(&c2, 0, 1, 0);

        // [ NO player ] -> [ player ]    : 1 added (Stationary)
        let mut c3 = Neighbor::new(vec![no_player.clone()]);
        let action = Neighbor::new(vec![player_any.clone()]);
        c3.prepare_actions(&action);
        check_counts(&c3, 0, 1, 0);

        // [ NO player ] -> [ player ]    : 1 added (Stationary)
        let mut c4 = Neighbor::new(vec![no_player.clone()]);
        let action = Neighbor::new(vec![player_any.clone()]);
        c4.prepare_actions(&action);
        check_counts(&c4, 0, 1, 0);

        // [ NO player ] -> [ > player ]  : 1 added (Right)
        let mut c5 = Neighbor::new(vec![no_player.clone()]);
        let action = Neighbor::new(vec![player_right.clone()]);
        c5.prepare_actions(&action);
        check_counts(&c5, 0, 1, 0);

        // [ player ] -> [ ]              : 1 removed
        let mut c6 = Neighbor::new(vec![player_any.clone()]);
        let action = Neighbor::new(vec![]);
        c6.prepare_actions(&action);
        check_counts(&c6, 0, 0, 1);

        // Check that the Neighbors change the Cell properly
        let mut board = Board::new(1, 1);
        let origin = Position::new(0, 0);

        assert!(!board.has_sprite(&origin, &player)); // player is not in the Cell yet

        let magic_or_tiles = FnvHashMap::default();

        assert!(c2.evaluate(&mut rng, &mut board, &origin, &magic_or_tiles)); // [ ] -> [ player ]
        assert!(board.has_sprite(&origin, &player));
        assert_eq!(
            board.get_wants_to_move(&origin, player.collision_layer),
            Some(WantsToMove::Stationary)
        );

        assert!(c1.evaluate(&mut rng, &mut board, &origin, &magic_or_tiles)); // [ player ] -> [ > player ]
        assert!(board.has_sprite(&origin, &player));
        assert_eq!(
            board.get_wants_to_move(&origin, player.collision_layer),
            Some(WantsToMove::Right)
        );

        assert!(c6.evaluate(&mut rng, &mut board, &origin, &magic_or_tiles)); // [ player ] -> [ ]
        assert!(!board.has_sprite(&origin, &player));
    }

    #[test]
    fn replace_tile_with_random() {
        let mut rng = new_rng();
        let player = SpriteState::new(&String::from("player"), 33, 44);
        let bat = SpriteState::new(&String::from("bat"), 34, 44);
        // let cat = SpriteState::new(&String::from("cat"), 35, 44);

        let player_any = build_t(false /*random*/, &player, false, None);
        let animal_any = build_t(true, &bat, false, None);

        // [ player ] -> [ RANDOM animal ]: 1 removed, 1 added
        let mut c1 = Neighbor::new(vec![player_any.clone()]);
        let action = Neighbor::new(vec![animal_any.clone()]);
        c1.prepare_actions(&action);
        check_counts(&c1, 0, 1, 0);

        // Check that the Neighbors change the Cell properly
        let mut board = Board::new(1, 1);
        let origin = Position::new(0, 0);

        board.add_sprite(&origin, &player, WantsToMove::Stationary);

        let magic_or_tiles = FnvHashMap::default();

        assert!(c1.evaluate(&mut rng, &mut board, &origin, &magic_or_tiles));
        assert!(!board.has_sprite(&origin, &player));
        assert!(board.has_sprite(&origin, &bat));
    }

    #[test]
    fn prepare_neighbor_multiple_single_sprites() {
        let player = SpriteState::new(&String::from("player"), 0, 44);
        let hat = SpriteState::new(&String::from("hat"), 0, 55);

        let player_any = build_t(false /*random*/, &player, false, None);
        let player_right = build_t(
            false, /*random*/
            &player,
            false,
            Some(WantsToMove::Right),
        );

        let hat_any = build_t(false /*random*/, &hat, false, None);
        let hat_left = build_t(false /*random*/, &hat, false, Some(WantsToMove::Left));

        // [ Player Hat ] -> [ > Player < Hat ] : 2 directions
        // [ ]        -> [ Player Hat ]         : 2 added (Stationary)
        // [ NO Player ] -> [ Player Hat ]      : 2 added (Stationary)
        // [ NO Player NO Hat ] -> [ > Player < Hat ]  : 2 added
        // [ Player NO Hat ] -> [ ]             : 1 removed
        // [ Hat ] -> [ NO Hat ]                : 1 removed
        // [ Player ] -> [ Hat ]                : 1 added, 1 removed

        // [ Player Hat ] -> [ > Player < Hat ] : 2 directions
        let mut c1 = Neighbor::new(vec![player_any.clone(), hat_any.clone()]);
        let action = Neighbor::new(vec![player_right.clone(), hat_left.clone()]);
        c1.prepare_actions(&action);
        check_counts(&c1, 2, 0, 0);

        // [ ]        -> [ Player Hat ]         : 2 added (Stationary)
        let mut c2 = Neighbor::new(vec![]);
        let action = Neighbor::new(vec![player_any.clone(), hat_any.clone()]);
        c2.prepare_actions(&action);
        check_counts(&c2, 0, 2, 0);

        // [ Player ] -> [ Hat ]                : 1 added, 1 removed
        let mut c2 = Neighbor::new(vec![player_any.clone()]);
        let action = Neighbor::new(vec![hat_any.clone()]);
        c2.prepare_actions(&action);
        check_counts(&c2, 0, 1, 1);
    }

    #[test]
    fn prepare_neighbor_or_tile() {
        let mut rng = new_rng();
        let player = SpriteState::new(&String::from("player"), 33, 44);
        let hat = SpriteState::new(&String::from("hat"), 55, 66);

        let thing_any = build_tile_with_modifier(false, true, false, None, &vec![player, hat]);

        // thing = player OR hat ...
        // [ thing ] -> [ ]               : 1 removed
        let mut c = Neighbor::new(vec![thing_any.clone()]);
        let action = Neighbor::new(vec![]);
        c.prepare_actions(&action);

        assert_eq!(c.pair_up_tiles(&action).len(), 2); // 2 because "player OR hat"
        check_counts(&c, 0, 0, 2); // 2 because "player OR hat"

        // Check that the Neighbors change the Cell properly
        let mut board = Board::new(1, 1);
        let origin = Position::new(0, 0);

        board.add_sprite(&origin, &player, WantsToMove::Stationary);

        let magic_or_tiles = FnvHashMap::default();

        assert!(c.evaluate(&mut rng, &mut board, &origin, &magic_or_tiles)); // [ thing ] -> [ ]
        assert!(!board.has_sprite(&origin, &player));
    }

    #[test]
    fn matches_empty_neighbor() {
        let player = SpriteState::new(&String::from("player"), 0, 44);
        let player_any = build_t(false /*random*/, &player, false, None);

        // [ ]        -> [ Player ]
        let mut c2 = Neighbor::new(vec![]);
        let action = Neighbor::new(vec![player_any.clone()]);
        c2.prepare_actions(&action);
        check_counts(&c2, 0, 1, 0);

        let origin = Position::new(0, 0);
        let board = Board::new(1, 1);
        assert!(c2.matches(&board, &origin));
    }

    #[test]
    fn remove_one_or_sprite_when_condition_has_no() { // See related remove_all_or_sprites_when_there_is_no_condition test
        let mut rng = new_rng();

        let player = SpriteState::new(&String::from("player"), 0, 44);
        let hat = SpriteState::new(&String::from("hat"), 1, 55);

        let marker = SpriteState::new(&String::from("marker"), 2, 66);
        let marker_any = build_t(false /*random*/, &marker, false, None);
        let no_marker = build_t(false /*random*/, &marker, true, None);

        let thing_any =
            build_tile_with_modifier(false, true, false, None, &vec![player.clone(), hat.clone()]);

        // thing = player OR hat ...
        // [ thing NO marker ] -> [ marker ]
        let mut c1 = Neighbor::new(vec![thing_any.clone(), no_marker.clone()]);
        let action = Neighbor::new(vec![marker_any.clone()]);
        c1.prepare_actions(&action);
        check_counts(&c1, 0, 1, 2);

        // Check that the Neighbors change the Cell properly
        let mut board = Board::new(1, 1);
        let origin = Position::new(0, 0);

        board.add_sprite(&origin, &player, WantsToMove::Stationary);
        board.add_sprite(&origin, &hat, WantsToMove::Stationary);

        assert!(board.has_sprite(&origin, &player));
        assert!(board.has_sprite(&origin, &hat));

        assert!(c1.evaluate(&mut rng, &mut board, &origin, &FnvHashMap::default()));

        assert!(board.has_sprite(&origin, &marker));

        // Verify that we only removed 1 of the sprites
        assert!(board.has_sprite(&origin, &player) || board.has_sprite(&origin, &hat));
        assert!(!(board.has_sprite(&origin, &player) && board.has_sprite(&origin, &hat)));
    }

    #[test]
    fn matches_two_ors() {
        let player = SpriteState::new(&String::from("player"), 2, 0);
        let bat = SpriteState::new(&String::from("bat"), 3, 1);

        // playerish = player OR ...
        // batish = bat OR ...
        let playerish = build_tile_with_modifier(
            false, /*random*/
            true,  /*is_or*/
            false, /*negated*/
            None,
            &vec![player],
        );
        let batish = build_tile_with_modifier(
            false, /*random*/
            true,  /*is_or*/
            false, /*negated*/
            None,
            &vec![bat],
        );

        let origin = Position::new(0, 0);
        let mut board = Board::new(1, 1);

        let n = Neighbor::new(vec![playerish, batish]);
        assert!(!n.matches(&board, &origin));

        board.add_sprite(&origin, &player, WantsToMove::Stationary);
        assert!(!n.matches(&board, &origin));

        board.add_sprite(&origin, &bat, WantsToMove::Stationary);
        assert!(n.matches(&board, &origin));
    }

    #[test]
    fn matches_no_or2() {
        let player = SpriteState::new(&String::from("player"), 2, 0);
        let bat = SpriteState::new(&String::from("bat"), 3, 1);

        // thing = player OR bat
        let no_thing = build_tile_with_modifier(
            false, /*random*/
            true,  /*is_or*/
            true,  /*negated*/
            None,
            &vec![player, bat],
        );

        let origin = Position::new(0, 0);
        let mut board = Board::new(1, 1);

        let n = Neighbor::new(vec![no_thing]);
        assert!(n.matches(&board, &origin));

        board.add_sprite(&origin, &player, WantsToMove::Stationary);
        assert!(!n.matches(&board, &origin));
    }
}
